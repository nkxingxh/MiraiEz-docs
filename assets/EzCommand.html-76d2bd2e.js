import{_ as o,M as c,p,q as d,R as t,t as e,N as n,a1 as s}from"./framework-96b046e1.js";const i={},l=t("h1",{id:"命令支持库",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#命令支持库","aria-hidden":"true"},"#"),e(" 命令支持库")],-1),r=t("p",null,[e("有时候需要让插件对某个命令做出处理 (如 "),t("code",null,"/ping github.com"),e("), 可以使用命令支持库的功能来注册相关命令。")],-1),u={class:"custom-container tip"},m=t("p",{class:"custom-container-title"},"提示",-1),h={href:"https://github.com/nkxingxh/MiraiEz/blob/main/plugins/MiraiEzCommand.php",target:"_blank",rel:"noopener noreferrer"},g=t("p",null,[t("strong",null,"尝试一下")],-1),_={href:"https://github.com/nkxingxh/MiraiEz/blob/main/plugins/exampleCmdReg.php",target:"_blank",rel:"noopener noreferrer"},b=s(`<h2 id="命令注册" tabindex="-1"><a class="header-anchor" href="#命令注册" aria-hidden="true">#</a> 命令注册</h2><p>如果你只想处理某些命令，你可以使用该命令注册命令处理函数。</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>命令与参数经过解析后将以数组的形式传入处理函数。你可以专注于实现你想要的功能而无需过多关注命令与参数的解析。</p></div><p><strong>定义</strong></p><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token function">cmdRegister</span><span class="token punctuation">(</span><span class="token variable">$func</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token variable">$commands</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">bool</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table><thead><tr><th>参数</th><th>类型</th><th>可选</th><th>说明</th></tr></thead><tbody><tr><td>func</td><td>mixed</td><td>false</td><td>要注册的 匿名函数 (Closure) 或 方法名 (必须是<strong>公有</strong>方法)</td></tr><tr><td>commands</td><td>string</td><td>false</td><td>要注册的命令 (支持多级, 可传入多个)</td></tr></tbody></table><p><strong>命令</strong></p><p>命令必须以 <code>/</code> 作为开头，否则将跳过处理。命令可包含多段，使用单个空格分隔。</p>`,8),v=t("code",null,"<消息类型>",-1),k={href:"https://github.com/project-mirai/mirai-api-http/blob/master/docs/api/MessageType.md#%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"},x=s(`<p><em>例如匹配图片 <code>&lt;Image&gt;</code>、匹配 At <code>&lt;At&gt;</code>、匹配表情 <code>&lt;Face&gt;</code>。</em></p><p>对于文本命令，将不区分大小。</p><div class="custom-container tip"><p class="custom-container-title">通配</p><p>使用 <code>&lt;Plain&gt;</code> 匹配任意文本, 使用 <code>*</code> 匹配任意类型。</p></div><p>一些命令示例:</p><ul><li>纯文本命令，如 <code>/example cmd</code></li><li>混合命令，如 <code>/example &lt;At&gt;</code></li><li>带引用命令，如 <code>/example &lt;Quote&gt;</code></li><li>包含通配的命令，如 <code>/example *</code></li></ul><div class="custom-container tip"><p class="custom-container-title">消息类型</p><p>支持注册文本消息与其他类型消息共存的命令，且可以存在多个不同类型的消息。如 <code>/example &lt;At&gt; &lt;Image&gt; &lt;Quote&gt;</code>。</p></div><div class="custom-container tip"><p class="custom-container-title">命令匹配机制</p><p>命令的匹配机制为匹配开头，只需要注册的命令与当前命令的开头匹配将会触发处理函数。如消息 <code>/example &lt;At&gt; ...</code> 可以触发注册了 <code>/example</code> 命令的处理函数。</p></div><div class="custom-container tip"><p class="custom-container-title">带引用消息</p><p>如果消息中带引用 (Quote), 命令支持库在解析时会将其移至最后进行匹配。 你如果需要注册带引用的命令，请确保 <code>&lt;Quote&gt;</code> 位于最后。</p></div><div class="custom-container warning"><p class="custom-container-title">注意</p><p>当注册的命令存在其他类型消息时，务必注意这些参数的顺序。参数顺序不一致将不会触发对应的处理函数。 假设消息为 <code>/example &lt;At&gt; &lt;Image&gt;</code>, 则不能触发 <code>/example &lt;Image&gt; &lt;At&gt;</code> 的处理函数。</p></div><h2 id="处理函数" tabindex="-1"><a class="header-anchor" href="#处理函数" aria-hidden="true">#</a> 处理函数</h2><div class="custom-container tip"><p class="custom-container-title">提示</p><p>我们推荐开发者使用匿名函数 (Closure) 作为命令处理函数。</p></div><p>注册匿名函数 (Closure) 或在插件类内定义<strong>公有</strong>函数，用于处理注册的命令。</p><p><em>下面以一个匿名函数为例进行展示</em></p><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$_DATA</span><span class="token punctuation">,</span> <span class="token variable">$argc</span><span class="token punctuation">,</span> <span class="token variable">$args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_DATA</td><td>Array</td><td>webhook 上报的完整数据 (已解码 JSON)</td></tr><tr><td>argc</td><td>int</td><td>参数数量</td></tr><tr><td>args</td><td>Array</td><td>解析后的参数数组</td></tr></tbody></table><p><strong>返回</strong></p><div class="custom-container warning"><p class="custom-container-title">注意</p><p>请小心地使用<strong>拦截</strong>这一特性，这可能会导致其他插件或处理函数无法按预期完成其任务。</p></div><ul><li>返回 <code>(int) 1</code> 拦截当前消息或事件，将不再继续执行其他 <strong>hook 处理函数</strong> (包括其他插件的)。</li><li>返回 <code>(int) 2</code> 拦截当前命令，将不再继续执行其他<strong>命令处理函数</strong> (包括其他插件的)。</li><li>返回其他值无特殊效果。</li></ul>`,18);function f(A,E){const a=c("ExternalLinkIcon");return p(),d("div",null,[l,r,t("div",u,[m,t("p",null,[e("要使用命令支持库的功能，请安装"),t("a",h,[e("命令支持前置插件"),n(a)]),e("。")])]),g,t("p",null,[t("a",_,[e("命令注册示例插件"),n(a)])]),b,t("p",null,[e("使用尖括号 "),v,e(" 可以匹配指定的"),t("a",k,[e("消息类型"),n(a)]),e("，不使用尖括号则作为文本命令进行匹配。")]),x])}const B=o(i,[["render",f],["__file","EzCommand.html.vue"]]);export{B as default};
